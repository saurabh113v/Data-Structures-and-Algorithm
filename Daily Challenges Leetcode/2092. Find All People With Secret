class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
         // Track which people know the secret
        boolean[] knowsSecret = new boolean[n];
        knowsSecret[0] = true;  // Person 0 initially knows the secret
        knowsSecret[firstPerson] = true;  // firstPerson initially knows the secret
      
        // Sort meetings by time
        int totalMeetings = meetings.length;
        Arrays.sort(meetings, Comparator.comparingInt(meeting -> meeting[2]));
      
        // Process meetings grouped by time
        for (int i = 0; i < totalMeetings;) {
            // Find all meetings happening at the same time
            int endIndex = i;
            while (endIndex + 1 < totalMeetings && 
                   meetings[endIndex + 1][2] == meetings[i][2]) {
                endIndex++;
            }
          
            // Build adjacency list for people meeting at this time
            Map<Integer, List<Integer>> adjacencyList = new HashMap<>();
            Set<Integer> peopleInCurrentTime = new HashSet<>();
          
            for (int k = i; k <= endIndex; k++) {
                int person1 = meetings[k][0];
                int person2 = meetings[k][1];
              
                // Create bidirectional edges
                adjacencyList.computeIfAbsent(person1, key -> new ArrayList<>()).add(person2);
                adjacencyList.computeIfAbsent(person2, key -> new ArrayList<>()).add(person1);
              
                // Track all people involved in meetings at this time
                peopleInCurrentTime.add(person1);
                peopleInCurrentTime.add(person2);
            }
          
            // BFS to spread the secret among connected people at this time
            Deque<Integer> queue = new ArrayDeque<>();
          
            // Start BFS from people who already know the secret
            for (int person : peopleInCurrentTime) {
                if (knowsSecret[person]) {
                    queue.offer(person);
                }
            }
          
            // Spread the secret through the connected graph
            while (!queue.isEmpty()) {
                int currentPerson = queue.poll();
              
                // Share secret with all neighbors
                for (int neighbor : adjacencyList.getOrDefault(currentPerson, Collections.emptyList())) {
                    if (!knowsSecret[neighbor]) {
                        knowsSecret[neighbor] = true;
                        queue.offer(neighbor);
                    }
                }
            }
          
            // Move to next time group
            i = endIndex + 1;
        }
      
        // Collect all people who know the secret
        List<Integer> result = new ArrayList<>();
        for (int person = 0; person < n; person++) {
            if (knowsSecret[person]) {
                result.add(person);
            }
        }
      
        return result;
    }
}
