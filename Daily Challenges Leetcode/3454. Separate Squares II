import java.util.*;

class Solution {

    static class Event {
        long y;
        int type; // +1 = add, -1 = remove
        long x1, x2;

        Event(long y, int type, long x1, long x2) {
            this.y = y;
            this.type = type;
            this.x1 = x1;
            this.x2 = x2;
        }
    }

    public double separateSquares(int[][] squares) {

        List<Event> events = new ArrayList<>();

        for (int[] s : squares) {
            long x1 = s[0];
            long x2 = (long) s[0] + s[2];
            long y1 = s[1];
            long y2 = (long) s[1] + s[2];

            events.add(new Event(y1, +1, x1, x2));
            events.add(new Event(y2, -1, x1, x2));
        }

        // Sort events by y
        events.sort(Comparator.comparingLong(e -> e.y));

        // Step 1: compute total union area
        double totalArea = computeTotalArea(events);
        double half = totalArea / 2.0;

        // Step 2: sweep again to find split y
        TreeMap<Long, Integer> active = new TreeMap<>();
        long prevY = events.get(0).y;
        double areaSoFar = 0;

        for (Event e : events) {
            long curY = e.y;
            double height = curY - prevY;

            if (height > 0) {
                double width = computeUnionWidth(active);
                double slabArea = width * height;

                if (areaSoFar + slabArea >= half) {
                    return prevY + (half - areaSoFar) / width;
                }

                areaSoFar += slabArea;
            }

            updateActive(active, e);
            prevY = curY;
        }

        return prevY;
    }

    // Compute total union area using sweep line
    private double computeTotalArea(List<Event> events) {
        TreeMap<Long, Integer> active = new TreeMap<>();
        long prevY = events.get(0).y;
        double area = 0;

        for (Event e : events) {
            long curY = e.y;
            double height = curY - prevY;

            if (height > 0) {
                area += computeUnionWidth(active) * height;
            }

            updateActive(active, e);
            prevY = curY;
        }

        return area;
    }

    // Update active x-intervals safely
    private void updateActive(TreeMap<Long, Integer> active, Event e) {
        active.put(e.x1, active.getOrDefault(e.x1, 0) + e.type);
        active.put(e.x2, active.getOrDefault(e.x2, 0) - e.type);

        if (active.get(e.x1) == 0) active.remove(e.x1);
        if (active.get(e.x2) == 0) active.remove(e.x2);
    }

    // Compute union width of active x-intervals
    private double computeUnionWidth(TreeMap<Long, Integer> map) {
        long prev = 0;
        int count = 0;
        double width = 0;

        for (Map.Entry<Long, Integer> entry : map.entrySet()) {
            long x = entry.getKey();
            if (count > 0) {
                width += x - prev;
            }
            count += entry.getValue();
            prev = x;
        }

        return width;
    }
}
